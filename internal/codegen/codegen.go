package codegen

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/marnixbouhuis/confpb/internal/version"
	"github.com/marnixbouhuis/confpb/pkg/runtime"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

var runtimePackage = protogen.GoImportPath("github.com/marnixbouhuis/confpb/pkg/runtime")

type FileGeneratorFunc func(plugin *protogen.Plugin, file *protogen.File) error

func RunProtocPlugin(generator FileGeneratorFunc) {
	opts := &protogen.Options{}
	opts.Run(func(plugin *protogen.Plugin) error {
		return InvokeGeneratorForFiles(plugin, generator)
	})
}

func InvokeGeneratorForFiles(plugin *protogen.Plugin, generator FileGeneratorFunc) error {
	plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL | pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
	plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO3
	plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2023

	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}
		if err := generator(plugin, file); err != nil {
			return fmt.Errorf("failed to generate code for file (\"%s\"): %w", file.Desc.Path(), err)
		}
	}
	return nil
}

// NewFileWithBoilerplate creates a new file with the specified name and prints the starting lines for a generated go file.
// It starts with some comments containing information about what program was used to generate this file.
// It then prints the go package, and lastly adds a runtime compatibility check to make sure the runtime has the correct
// version.
func NewFileWithBoilerplate(plugin *protogen.Plugin, file *protogen.File, fileName string) *protogen.GeneratedFile {
	g := plugin.NewGeneratedFile(fileName, file.GoImportPath)

	name, _ := os.Executable() // Ignore error, this is not critical
	name = filepath.Base(name)
	g.P("// Code generated by ", name, ". DO NOT EDIT.")
	g.P("// Version: ", version.GitReleaseVersion, ", (", version.GitReleaseTag, ", ", version.GitShortCommit, ")")
	g.P("// Runtime version: ", runtime.Version)
	g.P()

	g.P("package ", file.GoPackageName)
	g.P()

	// Generate version compatibility compile checks
	g.P("const (")
	g.P("// Make sure that the generated code version is supported by the installed runtime.")
	g.P("// If this compile time check fails, re-generated the code with a newer version of ", name, ".")
	g.P("_ = ", runtimePackage.Ident("EnforceVersion"), "(", runtime.Version, " - ", runtimePackage.Ident("MinimumSupportedCodegenVersion"), ")")
	g.P("// Make sure that the installed runtime is sufficiently up-to-date for this generated code.")
	g.P("// If this compile time check fails, update the runtime package.")
	g.P("_ = ", runtimePackage.Ident("EnforceVersion"), "(", runtimePackage.Ident("Version"), " - ", runtime.Version, ")")
	g.P(")")
	g.P()

	return g
}

// IterateMessages iterates over all messages (including embedded nested messages).
// It skips internal auto generated messages for things like maps.
// It calls fn for each message. If fn returns an error, iterateMessages will also error.
// We can't use go 1.23 iterator functions here yet since we support a minimum of go version 1.22.
func IterateMessages(messages []*protogen.Message, fn func(message *protogen.Message) error) error {
	for _, message := range messages {
		if message.Desc.IsMapEntry() {
			// Message is an auto generated message for map entries, skip it.
			return nil
		}

		if err := IterateMessages(message.Messages, fn); err != nil {
			return fmt.Errorf("failed to process sub message (parent=\"%s\"): %w", message.Desc.FullName(), err)
		}

		if err := fn(message); err != nil {
			return fmt.Errorf("failed to process message \"%s\": %w", message.Desc.FullName(), err)
		}
	}
	return nil
}

// NeedsPointer returns if a field needs a pointer for setting the value.
func NeedsPointer(f *protogen.Field) bool {
	if f.Desc.IsList() {
		// The go code generator does not use pointers for lists
		return false
	}

	if f.Desc.IsMap() {
		// The go code generator does not use pointers for maps
		return false
	}

	if f.Parent != nil && f.Parent.Desc.IsMapEntry() {
		// No extra pointers needed for map keys / values
		return false
	}

	if f.Desc.Kind() == protoreflect.BytesKind {
		// No need to use extra pointer for bytes since it's already a slice
		return false
	}

	if f.Desc.Kind() == protoreflect.MessageKind {
		// No need to use extra pointer for message kind since it already has a pointer
		return false
	}

	if f.Oneof != nil {
		// Oneofs don't use pointers for field presence since the container message already has a pointer
		return false
	}

	// Use a pointer if the field has presence tracking
	return f.Desc.HasPresence()
}
